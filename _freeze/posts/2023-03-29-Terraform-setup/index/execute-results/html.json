{
  "hash": "c84e40e0da62964b008590606a413d14",
  "result": {
    "markdown": "---\nimage: tf.png\ntitle: Setup Terraform\ndescription: \"A small guide to Terraform installed in Mac and Ubuntu\"\ndate: \"2023-03-29\"\nauthor: Deepak Ramani\nformat: \n  html: \n    code-annotations: hover\n    code-overflow: wrap\n---\n\n# Introduction\n\n[Terraform](https://developer.hashicorp.com/terraform) from Hasicorp is Infrastructure as Code(**IaC**) tool that is gaining popularity among the data engineers. It lets us build, change and version infrastructure safely and efficiently. As to why one needs Terraform, I shall direct you to [this comprehensive article](https://blog.gruntwork.io/why-we-use-terraform-and-not-chef-puppet-ansible-saltstack-or-cloudformation-7989dad2865c). \n\nIn this post, I will write a small guide to get us started with Terraform. This post then can be used as a starting guide for my future posts involving Terraform. \n\n::: {.callout-note}\nNote that this installation guide is only for Mac(M1 silicon) and Ubuntu(GCP E2-medium instance). Also this guide will look similar to the example provided in Hashicorp's website. The intention is to have a guide for my benefit in one place.\n::: \n\n### Prerequisites\nA fully functional Macbook or an Ubuntu GCP/AWS instance with `sudo` privileges. \n\n# Terraform Install\nI follow the Hashicorp [guide](https://developer.hashicorp.com/terraform/tutorials/docker-get-started/install-cli#install-terraform) and give commentary when needed. \nWe will use [Homebrew](https://brew.sh) tool in Mac to install. Install it if you haven't already. \n\n:::{ .panel-tabset}\n### Mac\n\n```{.bash filename=\"Terminal for Mac\"}\n/bin/bash -c \\\n\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # <1>\nbrew tap hashicorp/tap # <1>\nbrew install hashicorp/tap/terraform # <2>\nwhich terraform # <3>\nterraform --version # <4>\n```\n1. Install homebrew\n2. Install latest Terraform\n3. To check if terraform is correctly installed. It should display `/opt/homebrew/bin/terraform`. Otherwise check `PATH`.\n4. Verify installation\n\n### Ubuntu(20.04LTS)\n\n```{.bash filename=\"Terminal for Ubuntu\"}\n# Commands so far installs Hashicorp's GPG key, its repo, \n#verifies key's fingerprint. \n#Don't worry if you see gibberish after executing the second command. \n#Carry on with next commands.\nsudo apt update && sudo apt install -y gnupg software-properties-common curl \ncurl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -\nsudo apt-add-repository \"deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main\"\nsudo apt update && sudo apt-get install terraform # <1>\nterraform --version # <2>\n```\n1. Update system and install terraform\n2. Verify installation\n\n::: \n\nAdditionally, operating from terminal can be strengthened using `tab completion`. Refer [this](https://developer.hashicorp.com/terraform/tutorials/docker-get-started/install-cli#enable-tab-completion).\n\n# Docker Installation - Optional but recommended\n\n::: { .panel-tabset}\n\n### Mac\n\n``` {.bash filename=\"Terminal\"}\ncd ~\nwget https://desktop.docker.com/mac/main/arm64/Docker.dmg\n```\nDouble click on the `.dmg` file to install. Refer this [section](https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac) for more.\n\n::: { .callout-note}\nNote that both docker engine and docker-compose are bundled with desktop in Mac\n:::\n\n### Ubuntu Compute instance\nSince we're using a cloud instance we don't need to install docker desktop. We can go ahead install just `docker` engine and `docker-compose`.\n\n``` {.bash filename=\"Terminal\"}\ncd ~\nsudo apt update && sudo apt install docker.io -y # <1>\nmkdir soft && cd soft \nwget https://github.com/docker/compose/releases/download/v2.17.2/docker-compose-linux-x86_64 -O docker-compose \nchmod +x docker-compose # <2>\necho 'export PATH=\"/home/'$USER'/soft:$PATH\"' >> ~/.bashrc # <3>\nsudo groupadd docker \nsudo usermod -aG docker $USER # <4>\n```\n1. Update system and install docker-enginer\n2. Create a new directory, download docker-compose and make it executable\n3. Export the path of the docker-compose exe to system's PATH.\n4. Add docker to the group and user management.\n\nNow logout and log back into the instance.\nTo test if docker is installed correctly run,\n``` {.bash filename=\"Terminal\"}\ndocker run --rm hello-world # <1>\n```\n1. `hello-world` docker image will be downloaded and run. A message `Hello from Docker!` will be displayed.\n\n:::\n\n# Getting started with Terraform\n\n1. In Mac start `docker-desktop` either clicking the app or using `open -a Docker` in terminal. In `Ubuntu` the `docker-engine` is running in the background so this step is not needed.\n2. Make a new directory for this tutorial using `mkdir tf-tryout` and go inside it.\n3. Create a `main.tf` and copy the following contents into it.\n\n\n``` {json filename=\"main.tf\"}\nterraform {\n  required_providers {\n    docker = {\n      source  = \"kreuzwerker/docker\"\n      version = \"~> 3.0.1\"\n    }\n  }\n} # <1>\nprovider \"docker\" {} \nresource \"docker_image\" \"nginx\" {\n  name         = \"nginx\"\n  keep_locally = false\n} # <2>\nresource \"docker_container\" \"nginx\" {\n  image = docker_image.nginx.image_id\n  name  = \"tutorial\"\n  ports {\n    internal = 80\n    external = 8000\n  }\n} # <3>\n```\n\n1. Check terraform version and downloads a docker plugin \n2. Downloads the nginx docker image\n3. Create a nginx docker container and maps the port 80 to 8000\n\n\n## What is main.tf?\nIt is a terraform configuration file that describes infrastructure in Terraform. Each terraform config needs a separate directory with a single `main.tf`. \n\nThis file contains:\n\n- Terraform block\n- Providers\n- Resources\n\n### Terraform block \nThis block contains Terraform settings for require providers that Terraform will use to provision infrastructure. In our case it is `kreuzwerker/docker` as `source`. `kreuzwereker` is the provider/developer/host and `docker` is the product we are interested in using. We can specify the minimum version to install. If not mentioned, Terraform will install the lastest version available. Terraform registry is default place to look for popular providers such as AWS, GCP, Azure.\n\n```\nterraform {\n  required_providers {\n    docker = {\n      source  = \"kreuzwerker/docker\"\n      version = \"~> 3.0.1\"\n    }\n  }\n}\n```\n\n### Providers\nNow that Terraform knows the \"source\", we need to provide a \"provider\". Docker is our choice. In this block we can configure `docker` provider.\n```\nprovider \"docker\" {}\n```\n\n### Resources \nA resource block is used to define components of the provider previously mentioned. So we have a docker provider. We need a docker image and build a container for that image. \n\n```\nresource \"docker_image\" \"nginx\" {\n  name         = \"nginx\"\n  keep_locally = false\n}\nresource \"docker_container\" \"nginx\" {\n  image = docker_image.nginx.image_id\n  name  = \"tutorial\"\n  ports {\n    internal = 80\n    external = 8000\n  }\n}\n```\nThe resource block takes two strings - `resource type` and `resource name`.\n`docker_image` is the type and `nginx` is the name. These two together `docker_image.nginx` form a unique ID for the resource. For `docker_container` resource, we use the image from the previous block as reference. So a container is created with that image and ports are also mapped.\n\n## Validate and initialise the configuration\n\nTerraform has a bunch of CLI commands to make things easier and faster. One needs to remember only 5-6 commands. Rest can be looked up later. \n\nTo validate the configuration we use \n```\nterrform validate # <1>\n```\n1. Returns \"Success! The configuration is valid.\" if syntactically valid.\n\nThen we need to initialise our configuration. This process will download and install the providers mentioned. This command will create a hidden directory `.terraform` and install `docker` provider. Terraform also creates a lock file named .terraform.lock.hcl which specifies the exact provider versions used, so that you can control when you want to update the providers used for your project.\n\n\n## Plan and create infrastructure\n\nTerraform allows us to see what will be created through `terraform plan` commands. This command is used to give an overview of the things that will be created. An extra, precautionary step. It looks trivial for our use case but imagine a big organisation with several team members managing infrastructure. Even deleting a resource accidently will create chaos. It is always advised to run `terraform plan`, overview and then go ahead with creating resources.\n\n`terraform apply` is then given to apply the configuration. This is then `approved` to actually create resources. In our case a `nginx` docker image is downloaded and container using that image is created with port forwarding.\n\n\n## Terraform state\n\nTerraform has a state(status) file which stores the current state(metadata) of the infrastructure. Any changes to the resource configuration will be reflected into this file. If working in a team, it is advised to store this state file remotely such as `s3`, `gcs` etc with versioning and state locking.\n\n## Result\nA nginx server has been started and we can access it through `http:127.0.0.1:8000`. \nWe will be greeted with a message \"Welcome to nginx!\".\n\nNote- include an image. Fix code annotations, code blocks.\n\n## Destroy infrastructure\n\nTo destroy resources after use, we can use `terraform destroy` command. Review the plan and approve it. Be cautious using this command in an organisation.\n\n# Conclusion\nWe setup Terraform in our machine, created an infrastructure and managed it. To know more about docker with terraform, refer [this](https://developer.hashicorp.com/terraform/tutorials/docker-get-started) guide.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}