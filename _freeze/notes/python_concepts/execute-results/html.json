{
  "hash": "409be1a4e544a367fcf5b94782a17bb6",
  "result": {
    "markdown": "---\ndate: \"2022-09-07\"\ndate-modified: \"2023-04-05\"\ntoc: true\ntitle: Python concepts notes\ndescription: Notes on some of Python concepts\n---\n\nThese are some of my notes on python concepts I gathered from various sources. \n\n## Super()\n`super()` allows to call the base class implicitly without the need to use the base class\nname explicitly. The main advantage is seen during multiple inheritance. The child classes\nthat may be using cooperative multiple inheritance will call the correct next parent class\nfunction in the *Method Resolution Order*(MRO).\n\n**Syntax**\n*Python3* `super().__init__()`\n*Python2 and still valid in python3* `super(childclassname,self).__init__()`\n\n**Avoid** using like this -- `super(self.__class__,self).__init__()`. This leads to\nrecursion but fortunately python3 syntax standard side steps this problem.\n\nMore info in [stackoverflow](https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods)\n\n## \\_\\_Pycache\\_\\_\n`__pycache__` is a directory containing python3 bytecode compiled and ready to be\nexecuted. This is done to speed up loading of the modules. Python caches the compiled\nversion of each module in this directory. \nMore info in the python official [docs](https://docs.python.org/3/tutorial/modules.html#compiled-python-files)\n\n## Zip function\nThis function enables combination of elements in 2 or more lists. If the lists are of\nunequal lengths then the minimum length is taken. \n\nFor example - \n`zip([1,2,3],[\"one\", \"two\"])` returns a tuple `(1, \"one\"), (2, \"two\")`. Notice how *3* is\nnot part of the zip operation. \n\n<!-- ### Rotate a matrix/image by ![formula](https://render.githubusercontent.com/render/math?math=\\large%20\\bf%2090^\\circ) -->\n\n\n\n## Lambda function\nAlso knows as anonymous functions helps reduce the need to define unnecessary custom\nfunctions. For example, a function that returns a simple arithmetic operation can be made\nas a lambda function. \n\nExample -\n`lambda x,y,...: x+y+...` - lambda takes several arguments but returns only one expression.\n\n## Map function\nMap is a function that allows some kind of function upon a sequence. This sequence can be\nlist, tuple, string etc.\n\n_Syntax_: map(function, seq)\n\nlambda functions are commonly used with map functions.\n\nExample - \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nx = [1,2,3,4]\ndef square(x):\n    return x*x\nmap(square,x) #-->returns an iterator in python3.\n#To return in the desired sequence, use that as prefix in map. \nlist(map(square,x)) #--> returns as a list.\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n[1, 4, 9, 16]\n```\n:::\n:::\n\n\nWith lambda function:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\na = [1,2,3,4]\nlist(map(lambda x:x*x,a))\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n[1, 4, 9, 16]\n```\n:::\n:::\n\n\nWith map more than one sequence can be used -\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nb = [1, 1, 1, 1]\nlist(map(lambda x,y:x+y, a,b))    \n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[2, 3, 4, 5]\n```\n:::\n:::\n\n\n## Filter function\nThis function is used to filter the outputs if the sequence satisfies some condition. This\ncan be easily written as a list comprehension or a generator. \n`list(filter(lambda x:x%2==0, range(1,11))`\n\n## Reduce function\nThis was removed from the inbuilt functions in python3 and added to functools.\nIt is similar to map function but unlike map it takes only one iterable. \n`list(reduce(lambda x,y:x+y, a))`. Internally assigns x and y and calculates the desired\nfunction.\n\n**Each of the above function can be substituted with list comprehension.**\n\n### namespace and variable scope\n\nNamespace is the space occupied by an entity in the program. When two or more programs\ncontain the same name, a method to invoke a unique program is done using its module name.\n\n### LEGB Rule\n\nVariable scope has three visibilty levels -- builtin, global, enclosed, and local.\n\n*Local scope* - variables defined inside a local function. Their lifecycle ends with the\nlocal function.\n*Global scope* - variable defined at the top of the module and is available for all the\nfunctions underneath it.\n*Enclosed scope* - seen in nested function. \n*built-in scope* - names within python built-in functionality like print().\n\nChange a global variable inside a local function? use `global` keyword.\nChange a enclosed variable inside an enclosed(nested)-local function? use `nonlocal` keyword.\n**The order of execution follows local, enclosed, global, and built-in.**\n\n### Closures\n\nClosure is a concept to invoke an enclosed(nested)-local function outside of its scope. \nThis uses a python's property -- functions are first class object. \nExample -\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef f():\n    return 2\ng = f\n```\n:::\n\n\n`g` here gets the function f's location(*reference*) or the path of the function till the end of it. \nThis functionality is helpful in accessing an enclosed(nested)-local function beyond its scope. \n\nexample - \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef f():\n    x = 4\n    def g():\n        y = 3\n        return x+y\n    return g\n\na = f()\nprint(a) #--> returns path till function 'g'\nprint(a()) #--> returns 7\nprint(a.__name__) #--> return function 'g' name.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<function f.<locals>.g at 0x1037b8dc0>\n7\ng\n```\n:::\n:::\n\n\nWhy closures?\n* Avoid global values\n* Data hiding\n* Implement decorators\n\n### Decorators\nAny callable object that is used to modify a function or class. Adds additional\nfunctionality to existing function or class. Basically a wrapper around the existing\nfunction where the existing function code couldn't be changed but additional\nfeatures/checks are necessary. It is much easier to use the decorator than\nwriting one. The wrapper becomes complex as the functions it wraps get longer. \n\nA decorator should:\n* take a function as parameter\n* add functionality to the function\n* function needs to return another function\n\nTwo types:\n- Function decorator\n- Class decorator\n\n### function call as parameter\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef f1():\n    print(\"hello from f1\")\ndef f2(function):\n    print(\"hello from f2\")\n    function()\nf2(f1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello from f2\nhello from f1\n```\n:::\n:::\n\n\n### Multiple decorators\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef f1(func):\n    def inner():\n        return \"first \" + func() +\" first\"\n    return inner\n\ndef f2(func):\n    def wrapper():\n        return \"second \" + func()+\" second\"\n    return wrapper\n\n@f1\n@f2\ndef ordinary():\n    return \"good morning\"\n\nprint(ordinary())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfirst second good morning second first\n```\n:::\n:::\n\n\n`>>>> first second good morning second first`\n\nAt first, the f2 decorator is called and prints `second good morning second`, then f1\ndecorator takes that output and prefixes and suffixes with `first`.\n\n### Decorators with parameters\n\nTo pass parameters to a decorator, the nested function in the previous case must be\ndefined inside a function. \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef outer(x):\n    def f1(func):\n        def inner():\n            return func() + x\n        return inner\n    return f1\n\n\n@outer(\" everyone\")\ndef greet():\n    return \"good morning\"\n\nprint(greet)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<function outer.<locals>.f1.<locals>.inner at 0x13f874310>\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndef div1(a,b):\n    return a/b\n\ndef div2(a,b,c):\n    return a/b/c\n\nprint(div1(5,0))\nprint(div2(3,4,5))\n```\n\n::: {.cell-output .cell-output-error}\n```\nZeroDivisionError: division by zero\n```\n:::\n:::\n\n\nTo protect against division-by-zero error, a decorator is written.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef div_by_zero_dec(func):\n    def inner(*args):\n        for i in args[1:]:\n            if i == 0:\n               return \"Enter valid non-zero input for denominator\"\n        #gives the general error and not decorator output for div2 function if the input is zero\n        #answer =  [\"Enter valid non-zero input for denominator\" if i == 0 else func(*args) for i in args[1:]]\n        return func(*args)\n        #return answer  \n    return inner\n\n@div_by_zero_dec\ndef div1(a,b):\n    return a/b\n\n@div_by_zero_dec\ndef div2(a,b,c):\n    return a/b/c\n\nprint(div1(5,0))\nprint(div2(3,1,0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEnter valid non-zero input for denominator\nEnter valid non-zero input for denominator\n```\n:::\n:::\n\n\n### Data hiding\nDecorators inherently hides the original function. To avoid that we can use `wraps()`\nmethod from `functools`.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nfrom functools import wraps\ndef outer(x):\n    def f1(func):\n        @wraps(func)\n        def inner():\n            return func() + x\n        return inner\n    return f1\n\n\n@outer(\" everyone\")\ndef greet():\n    return \"good morning\"\n\nprint(greet.__name__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngreet\n```\n:::\n:::\n\n\n### Class decorators\n\nDecorator function can be applied to class methods also.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n#check for name equal to Justin is done with a decorator\ndef check_name(func):\n    def inner(name_ref):\n        if name_ref.name == \"Justin\":\n            return \"There is another Justin\"\n        return func(name_ref)\n    return inner\n\nclass Printing():\n    def __init__(self, name):\n        self.name = name\n    \n    @check_name\n    def print_name(self):\n        print(f\"username is {self.name}\")\n\np = Printing(\"Justin\")\np.print_name()\n#username is Justin\n#There is another Justin\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n'There is another Justin'\n```\n:::\n:::\n\n\nTo make a class decorator, we need to know about a special method called `__call__`. If a\n`__call__` method is defined, the object of a class can be used as function call.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nclass Printing():\n    def __init__(self, name):\n        self.name = name\n    \n    def __call__(self):\n        print(f\"username is {self.name}\")\n\np = Printing(\"Lindon\")\np()\n# username is Lindon\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nusername is Lindon\n```\n:::\n:::\n\n\n### Class decorator on a function\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nclass Decorator_greet:\n    def __init__(self, func):\n        self.func = func\n    def __call__(self):\n        return self.func().upper()\n\n@Decorator_greet\ndef greet():\n    return \"good morning\"\n\nprint(greet())\n#GOOD MORNING\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGOOD MORNING\n```\n:::\n:::\n\n\n### Built-in decorators\n* @property\n* @classmethod\n* @staticmethod\n\n### @property\n* Class methods as attributes\nThe idea of a wrapper is to  make changes to code base without hindering its use for the\nend user.\nUsing `@property` decorator, a class variable which is now a class method will give the\nresult if used just like accessing the variable.\nFor example - `objectname.function()` or `objectname.function` will give the same result without\nerrors. So the user can access just like they did previously. \n\nBorrowing idea from other programming languages, the private variables are defined with\n`__` prefix. So to access those variables, *getter, setter, and deleter* methods are\nnecessary. \nAccessing is done with getter method. So it gets `@property` decorator. Both setters and\ndeleters get `@functionname.setter` or `@functionname.deleter`. (*verify this. could be wrong*)\n\n\n* @classmethod\nInsted of `self`, the classmethod decorator takes `cls` as first argument for its\nfunction. These methods can access and modify class states.\n\n* @staticmethod\nThis is similar to classmethod but takes no predefined argument like instance method(self)\nor classmethod(cls). These methods can't access class state. So ideally they are used for\nchecking conditions.\n\n**Decorator Template**\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nimport functools\n\ndef my_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Do something before\n        result = func(*args, **kwargs)\n        # Do something after\n        return result\n    return wrapper\n```\n:::\n\n\n## Context Managers\n\nUsually `with` is used w.r.t to file operations, database connections. In addition to\nusing `with` and `as` keywords, we can make custom context managers using\n`@contextlib.contextmanger` which is a generator decorator. \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfrom contextlib import contextmanager\n\n@contextmanager\ndef opening(filename, method):\n    print(\"Enter\")\n    f = open(filename, method) \n    try:\n        yield f\n    finally:\n        f.close()\n        print(\"Exit\")\n\nwith opening(\"hello.txt\", \"w\") as f:\n    print(\"inside\")\n    f.write(\"hello there\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEnter\ninside\nExit\n```\n:::\n:::\n\n\n",
    "supporting": [
      "python_concepts_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}